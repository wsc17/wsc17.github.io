<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>mysql on Wushuchao | Blog</title>
    <link>https://wsc17.github.io/tags/mysql/</link>
    <description>Recent content in mysql on Wushuchao | Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 16 Nov 2023 14:39:30 +0800</lastBuildDate>
    <atom:link href="https://wsc17.github.io/tags/mysql/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Mysql 简易分布式锁</title>
      <link>https://wsc17.github.io/posts/mysql/mysql-simple-lock/</link>
      <pubDate>Thu, 16 Nov 2023 14:39:30 +0800</pubDate>
      <guid>https://wsc17.github.io/posts/mysql/mysql-simple-lock/</guid>
      <description>一、本文内容概述 介绍锁。
锁的实现之：Mysql分布式锁。
二、为什么需要锁 为什么需要用到锁，即：锁的作用是什么？可以用锁来解决什么问题？什么情况下需要用到锁？
（一）锁的使用场景 列举几个实际开发中需要用到锁的场景。
1.避免某个业务重复执行 例，系统A使用定时任务的方式，向系统B发送通知，并更新状态：
如果定时任务执行频率较快，且系统A业务执行较慢，就会出现：对于同一条通知，第一次发送尚未完成（状态还没有更新为已发送），第二次发送又开始了，导致同一条通知重复发送2次到系统B。
为了避免这种情况，可以在系统A对这个业务进行加锁，实现：第一次发送尚未完成时，如果第二次发送也触发了，则第二次发送需要等待，等第一次发送完成后，第二次再继续执行：
2.避免商品超卖 例，某商品库存只有10件，但有很多人同时来抢购商品，就可能会出现超卖（实际卖出的商品超过10件）。
此时通过加锁，保证：在一次购买结束后（库存扣减完成），再处理下一次购买：
三、什么是锁 那么锁到底是什么？
（一）锁是一种方法论 锁的本质，就是当资源发生竞争（同一个资源被多个对象竞争使用）时，把竞争变成排队执行，避免资源在同一时间内被多方同时使用。
锁，并不是一个具象的东西，它只是一种思想，一种解决问题的思路。
锁是一种方法论，需要开发者根据这个方法论的指导，去具体的实践，去实现锁。
（二）名词解释 1.加锁 （1）通过某种具体的方式（例，使用synchronized关键字修饰Java方法），使并发的线程排队执行，这个过程就称为加锁（获取锁）。
（2）线程排队执行时，每个线程都要先尝试加锁，如果加锁成功，则该线程可以继续执行。（3）反之，说明已经有其它线程获取了锁，则需要等待锁被释放。
（4）同时只会有一个线程加锁成功。
（5）多个线程时，哪个线程可以先加锁成功？
有些锁的实现方式，无法设置线程加锁成功的先后（即，随机的）。
有些锁的实现方式，可以一定程度上实现公平锁（先来后到）。
2.解锁 （1）某个线程加锁成功，并且执行结束后，需要解锁（释放锁）。
（2）此时正在排队的线程就可以尝试加锁，并且会有一个线程加锁成功。
3.锁超时 （1）有一些锁的实现方式，会给加锁的过程设置超时时间。超过这个时间后，就会释放锁。
（2）存在可能性：锁超时释放了锁，但线程并没有执行结束。此时，下一个线程获取到锁并且执行业务，则会导致上述的商品超卖问题。
（3）因此，需要开发者对超时时长设置一个合理值，但更重要的，应改优化业务代码，保证加锁过程中的业务代码不要执行太长时间。
（三）对同一个资源加锁 （1）并不是对所有操作都需要加锁，当资源发生竞争时，才需要加锁。例，有两个线程同时调用同一个接口来购买商品。但是，第一个线程购买的是商品A，第二个线程购买的是商品B，则不需要加锁，二者可并行执行。
（2）此时，在代码层面加锁时，可以对一个业务数据唯一标识进行加锁。例，对商品id进行加锁。当多个线程购买同一个商品id时，才加锁排队执行。
四、Mysql分布式锁 分布式的概念，这里不详细描述。
仅简单介绍系统的单体部署和多个部署。
（一）单体/多个部署 当系统使用量比较一般时，通常只部署一个SpringBoot应用即可。
当系统客户较多，使用频繁时，可能需要部署多个SpringBoot应用，以保证系统性能及可用性。此时，大多配合Nginx来部署系统：
如图，服务端多个部署的情况下，普通的锁（例，使用synchronized关键字修饰Java方法）都只是在各自的节点生效。
例，当2个客户端同时购买同一个商品，但是请求经过Nginx后，被转发到第1个和第2个服务端节点，则此时的锁就做不到让这两个请求排队执行（因为两个应用的代码是独立的）。
此时，就需要实现一个分布式锁。
（二）Mysql分布式锁 分布式锁的实现方式有很多，这里仅介绍基于Mysql的分布式锁的简单实现。
1.唯一索引（数据唯一性） （1）Mysql分布式锁的实现，可基于表的主键或者唯一索引，这里介绍使用唯一索引的方式。
（2）在Mysql中使用唯一索引时，可以保证数据的唯一性。例，在表t_lock中，有字段lock_key，如果给这个字段设置了唯一索引，那么lock_key字段的值就不能重复（重复时无法保存）。
（3）唯一索引的这一特性，可用于实现Mysql分布式锁。
2.锁实现原理 （1）新建t_lock表，有一列：lock_key，且给列设置唯一索引。
（2）加锁：往t_lock中插入一条数据，如果插入成功，则为加锁成功，反之则加锁失败。
（3）解锁：根据lock_key删除t_lock表的数据，删除成功即为解锁成功。
（4）例，同时有2个请求来更新【同一个用户】的账户余额：
每个请求都要先获取锁（往t_lock表插入一条数据，用户id即为lock_key的值）。
最先在t_lock中插入数据的请求（假设为A），即为加锁成功，可【持锁】继续处理后续业务。
在A解锁之前，其它请求一直无法插入数据，也就是无法加锁成功，需等待解锁。
A执行结束并解锁后，其它请求又可以尝试加锁。
以此类推。
3.锁的功能构成 （1）实现锁时，至少需要实现锁最基本的功能：加锁，解锁。
（2）此外，可拓展实现的功能：多次尝试加锁，超时自动解锁。
（3）多次尝试加锁
重试次数：在加锁失败后，再继续尝试加锁，在总共尝试K次加锁失败后，结束线程的执行。
重试间隔：每次重试需间隔一段时间。例，加锁失败后，等待5秒，再尝试下一次加锁。
（4）超时自动解锁</description>
    </item>
  </channel>
</rss>
